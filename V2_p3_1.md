# 3.1. Step-by-Step Architecture Implementation

The implementation of the architecture described in `V2_architecture_overview.md` is carried out step by step for each new functionality.

## Step 1: Setting up basic components (package `core`)

1. Create base classes for UI: `BaseActivity`, `BaseFragment`, `BaseViewModel`. These classes will contain common logic, such as handling states (loading, error), dependency injection, and subscribing to `ViewModel`.
2. Configure Hilt for dependency injection. Create an Application class annotated with `@HiltAndroidApp`.
3. Create main Hilt modules in the `core.di` package to provide project-wide dependencies (e.g., `Context`, `SharedPreferences`, `DispatcherProvider`).

## Step 2: Defining Domain Layer

1. In the `domain.model` package, define POKO classes (Plain Old Kotlin Objects) representing core business entities (e.g., `MediaFile`, `MediaResource`).
2. In the `domain.repository` package, define interfaces for repositories (e.g., `ResourceRepository`, `SettingsRepository`). These interfaces will serve as a contract for the data layer.
3. For each business operation, create a `UseCase` class in the `domain.usecase` package (e.g., `GetResourcesUseCase`, `UpdateResourceUseCase`). `UseCase` should depend only on repository interfaces.

## Step 3: Implementing Data Layer

1. In the `data.local.db` package, define Room components: `Entity` classes (annotated with `@Entity`), `DAO` interfaces (annotated with `@Dao`), and the `AppDatabase` class (inheriting from `RoomDatabase`).
2. In the `data.remote` package, implement clients for working with network protocols (SMB, SFTP) and cloud APIs.
3. In the `data.repository` package, create classes implementing the repository interfaces from `domain.repository`. These classes will encapsulate the logic for selecting the data source (local or remote) and mapping data models (from `Entity`/DTO to domain models).

## Step 4: Implementing UI Layer (for one feature)

1. In the `ui` package, create a subpackage for the new feature (e.g., `ui.main`).
2. Create a `Fragment` (e.g., `MainFragment`) that inherits from `BaseFragment`.
3. Create a `ViewModel` (e.g., `MainViewModel`) that inherits from `BaseViewModel`. Inject the necessary `UseCases` into it via the constructor annotated with `@HiltViewModel`.
4. In the `ViewModel`, define `StateFlow` for the screen state and `SharedFlow` for one-time events (e.g., navigation, showing Toast).
5. In the `Fragment`, subscribe to `Flow` from the `ViewModel` to update the UI and pass user events to the `ViewModel`.
6. Create an XML layout for the `Fragment` and, if necessary, an `Adapter` for `RecyclerView`.

## Step 5: Integration and testing

1. Add the created `Fragment` to the Navigation Component navigation graph.
2. Write Unit tests for `ViewModel`, `UseCases`, and repositories, using mock objects for dependencies.
3. Write instrumentation tests to verify the correctness of UI operation and component interactions.